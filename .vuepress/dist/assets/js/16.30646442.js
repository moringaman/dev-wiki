(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{151:function(t,a,s){"use strict";s.r(a);var n=s(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"blockchainjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blockchainjs","aria-hidden":"true"}},[t._v("#")]),t._v(" BlockChainjs")]),s("h2",{attrs:{id:"how-to-code-a-blockchain-in-javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-to-code-a-blockchain-in-javascript","aria-hidden":"true"}},[t._v("#")]),t._v(" How to code a blockchain in javascript")]),s("h3",{attrs:{id:"our-blockchain-class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#our-blockchain-class","aria-hidden":"true"}},[t._v("#")]),t._v(" Our Blockchain class")]),s("p",[t._v("We will code out our javascript blockchain as a class called Blockchain with an initial constructor\nwhich specifies two arrays. The first will contain our blocks and the other pending transactions until they are added to new blocks a they are mined.")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("\n"),s("span",{attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{attrs:{class:"token class-name"}},[t._v("Blockchain")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token function"}},[t._v("constructor")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{attrs:{class:"token comment"}},[t._v("// to contain an array of blocks")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pendingTransactions "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"the-createnewblock-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-createnewblock-function","aria-hidden":"true"}},[t._v("#")]),t._v(" The createNewBlock function")]),s("p",[t._v("In order to create our first block we need to create a function which inherits our blockchain classes methods and properties to do this we use prototypes.")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Blockchain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function-variable function"}},[t._v("createNewBlock")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" previousBlockHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hash"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" newBlock "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tindex"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lenght "),s("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("1")]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\ttimestamp"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Date"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("now")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\ttransactions"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pendingTransactions"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\tnonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\thash"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" hash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\tpreviousHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" previousBlockHash\n\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pendingTransactions "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("push")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newBlock"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" newBlock"),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Our newBlock object contains all the information we need for each block some refer to our previous block and the transactions contained in our block are taken from the pendingtransactions array. We then empty the pending transactions and push our new block onto our chain (array of block objects)")]),s("p",[t._v("creatNew block takes three variables nonce, hash and previousBlockHash")]),s("h3",{attrs:{id:"the-getlastblock-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-getlastblock-function","aria-hidden":"true"}},[t._v("#")]),t._v(" The getLastBlock function")]),s("p",[t._v("In order to privide our createNewBlock function with the previous blocks hash we need to get the previous block in our chain array/\nthis would be the last index - 1 (see code below)")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Blockchain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function-variable function"}},[t._v("getLastBlock")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain"),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("1")]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"creating-new-transactions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#creating-new-transactions","aria-hidden":"true"}},[t._v("#")]),t._v(" Creating New Transactions")]),s("p",[t._v("We also need a way to create new transactions which can record funds transfers from one wallet to another/\nthis function will then be pushed onto the pendingTransactions array of our chain prior to being mined/\nand placed into the transactions array of a newBlocks.")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Blockchain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function-variable function"}},[t._v("createNewTransaction")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("amount"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sender"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" recipient"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" newTransaction "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tamount"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" amount"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\tsender"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" sender"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\trecipient"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" recipient\n\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("chain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pendingTransactions"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("push")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newTransaction"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("getLastBlock")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token string"}},[t._v('"index"')]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("1")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("we also call getLastBlock to find the lastblock index and then add 1 to it so that we can report back the/\nblock number or (index) of where the transction will be created.")]),s("h2",{attrs:{id:"hashing-and-proof-of-work"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashing-and-proof-of-work","aria-hidden":"true"}},[t._v("#")]),t._v(" Hashing and Proof of Work")]),s("h3",{attrs:{id:"hashing-with-sha256-encryption"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashing-with-sha256-encryption","aria-hidden":"true"}},[t._v("#")]),t._v(" Hashing with sha256 Encryption")]),s("p",[t._v("In order to encrypt our blockchain in order to prevent it from being hacked and altered we will be hashing each of our blocks as well as running a proof of work/\nalgorithm in order to prove it's data integrity. First we introduce the hasBlock function which simply takes in three params concatinates them into a string/\nand then hashes the result.")]),s("p",[t._v("Our 3 parameters are previousBlockHash, currentBlockData and nonce..")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Blockchain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function-variable function"}},[t._v("hashBlock")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("previousBlockHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentBlockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" blockData "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" previousBlockHash "),s("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("toString")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("stringify")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("currentBlockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" hash "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token function"}},[t._v("sha256")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("blockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" hash"),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"the-proofofwork-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-proofofwork-function","aria-hidden":"true"}},[t._v("#")]),t._v(" The proofOfWork() Function")]),s("p",[t._v("We now need to create a way to ensure the integrity of our blockchain, now to do this we are going to try to always generate a hash value begging with 0000/\nGivern that we already know what our hashBlock method requires to create a hash we need to generate a nonce which will result in a correct hash given the\nprevousBlockHash and currentBlockData, which cannot be changed.")]),s("p",[t._v("We have to do this through trial and error passing our currentBlockData and previousBlockHash to sha256 whilst at the same time incrementing our nonce value from/\n0 upwards until the resulting hash starts with 0000. To do this we will use a simple while loop.")]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Blockchain"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function-variable function"}},[t._v("proofOfWork")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("previousBlockHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentBlockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" nonce "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("0")]),t._v("\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" hash "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("hashBlock")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("previousBlockHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentBlockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("hash"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("substring")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token number"}},[t._v("0")]),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{attrs:{class:"token number"}},[t._v("4")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),s("span",{attrs:{class:"token string"}},[t._v('"0000"')]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tnonce"),s("span",{attrs:{class:"token operator"}},[t._v("++")]),t._v("\n\thash "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("this")]),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("hashBlock")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("previousBlockHash"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentBlockData"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\n\t"),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" nonce"),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Finally we return our nonce value as this is what we will use whenever we hash a new block as part of out mining process.")])])}],!1,null,null,null);a.default=o.exports}}]);